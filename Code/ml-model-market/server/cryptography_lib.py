# cryptography_lib.py

import hashlib
from ecdsa import SigningKey, VerifyingKey, NIST256p

# --- Part 1: Digital Signatures using a real library (ecdsa) ---

def generate_keys():
    """
    Generates a new ECDSA private and public key pair.
    
    Returns:
        tuple: (private_key, public_key) objects.
    """
    private_key = SigningKey.generate(curve=NIST256p)
    public_key = private_key.verifying_key
    return private_key, public_key

def sign(private_key, data_hash):
    """
    Signs a data hash with a private key.

    Args:
        private_key (SigningKey): The seller's private key.
        data_hash (bytes): The hash of the data to be signed.

    Returns:
        bytes: The digital signature.
    """
    return private_key.sign(data_hash)

def verify_signature(public_key, signature, data_hash):
    """
    Verifies a signature against a data hash and public key.

    Args:
        public_key (VerifyingKey): The seller's public key.
        signature (bytes): The signature to verify.
        data_hash (bytes): The hash of the original data.

    Returns:
        bool: True if the signature is valid, False otherwise.
    """
    try:
        return public_key.verify(signature, data_hash)
    except Exception:
        return False

# --- Part 2: Zero-Knowledge Proofs (ZKP) - Mock Implementation ---
# In a real-world application, this would be replaced by a dedicated ZKP framework
# like ZoKrates, Circom, or zksk. The goal here is to prove knowledge of the
# private key that corresponds to the public key, without revealing the private key.

def generate_zkp_of_signature(data_hash, signature, public_key):
    """
    (MOCK) Generates a Zero-Knowledge Proof of knowledge of the private key.

    This function simulates the creation of a ZKP that proves the statement:
    "I know the private key 'sk' that corresponds to the public key 'pk', 
    such that this 'signature' was generated by signing 'data_hash' with 'sk'."

    Args:
        data_hash (bytes): The hash of the data.
        signature (bytes): The signature of the data hash.
        public_key (VerifyingKey): The public key.

    Returns:
        dict: A mock proof object. In a real system, this would be a complex
              cryptographic object.
    """
    # A real ZKP would involve complex mathematics (e.g., elliptic curve pairings,
    # polynomial commitments). Here, we just bundle the inputs as a "proof".
    print(f"    [Crypto] Generating mock ZKP for data hash {data_hash.hex()[:10]}...")
    return {
        "type": "ZKP_Signature_Proof",
        "public_key": public_key.to_string().hex(),
        "data_hash": data_hash.hex(),
        "statement": "Proof of knowledge of the private key for the given public key."
    }

def verify_zkp(public_key, data_hash, zkp):
    """
    (MOCK) Verifies a Zero-Knowledge Proof.

    This function simulates the verification process. A real verifier would
    check the mathematical validity of the proof without learning the secret.

    Args:
        public_key (VerifyingKey): The public key associated with the proof.
        data_hash (bytes): The data hash associated with the proof.
        zkp (dict): The mock proof object.

    Returns:
        bool: True, simulating a successful verification.
    """
    print(f"    [Crypto] Verifying mock ZKP for public key {public_key.to_string().hex()[:10]}...")
    # In a real system, this would return the result of a complex cryptographic check.
    # For our simulation, we assume the proof is always valid if generated.
    is_valid = (zkp["public_key"] == public_key.to_string().hex() and 
                zkp["data_hash"] == data_hash.hex())
    return is_valid