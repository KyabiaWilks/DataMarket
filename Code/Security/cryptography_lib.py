import hashlib
from tokenize import group
from ecdsa import SigningKey, VerifyingKey, NIST256p
from petlib.ec import EcGroup, EcPt 
from zksk import Secret
from zksk.primitives.dlrep import DLRep
from zksk.utils import make_generators

# ===============================================================
# 第一部分：使用ecdsa库实现数字签名
# 该部分实现了ECDSA（椭圆曲线数字签名算法）来生成密钥对、签名数据和验证签名
# 这对于确保数据的完整性和验证卖家的身份非常重要
# ===============================================================


def generate_keys():
    """
    生成新的ECDSA私钥和公钥对
    Returns:
        tuple: 包含私钥和公钥的元组 (SigningKey, VerifyingKey)
    """
    private_key = SigningKey.generate(curve=NIST256p)
    public_key = private_key.verifying_key
    return private_key, public_key


def sign(private_key, data_hash):
    """
    使用私钥对数据哈希进行签名

    Args:
        private_key (SigningKey): 卖家的私钥
        data_hash (bytes): 要签名的数据的哈希值

    Returns:
        bytes: 签名后的数据
    """
    return private_key.sign(data_hash)


def verify_signature(public_key, signature, data_hash):
    """
    验证签名是否与数据哈希和公钥匹配

    Args:
        public_key (VerifyingKey): 卖家的公钥
        signature (bytes): 要验证的签名
        data_hash (bytes): 原始数据的哈希值

    Returns:
        bool: 如果签名有效，返回True；否则返回False
    """
    try:
        return public_key.verify(signature, data_hash)
    except Exception:
        return False


# ===============================================================
# 第二部分：模拟零知识证明 (ZKP) 的实现
# 在实际应用中，这将被专用的零知识证明 (ZKP) 框架所取代，例如 ZoKrates、Circom 或 zksk
# 其目标是在不泄露私钥的情况下，证明用户知晓与公钥对应的私钥
# ===============================================================


# def generate_zkp_of_signature(data_hash, signature, public_key):
#     """
#     (MOCK) 生成对私钥知识的零知识证明

#     这个函数模拟创建一个零知识证明 (ZKP)，以证明以下语句：
#     "I know the private key 'sk' that corresponds to the public key 'pk',
#     such that this 'signature' was generated by signing 'data_hash' with 'sk'."

#     Args:
#         data_hash (bytes): 数据的哈希值
#         signature (bytes): 数据哈希的签名
#         public_key (VerifyingKey): 公钥

#     Returns:
#         dict: 模拟的证明对象在实际系统中，这将是一个复杂的加密对象
#     """
#     # 一个真正的零知识证明将涉及复杂的数学（例如椭圆曲线配对、多项式承诺），这里我们只是将输入打包为一个“证明”
#     print(f"    [Crypto] Generating mock ZKP for data hash {data_hash.hex()[:10]}...")
#     return {
#         "type": "ZKP_Signature_Proof",
#         "public_key": public_key.to_string().hex(),
#         "data_hash": data_hash.hex(),
#         "statement": "Proof of knowledge of the private key for the given public key.",
#     }


# def verify_zkp(public_key, data_hash, zkp):
#     """
#     (MOCK) 验证零知识证明（这个函数模拟验证过程，真正的验证者会在不泄露秘密的情况下检查证明的数学有效性）

#     Args:
#         public_key (VerifyingKey): 与证明相关的公钥
#         data_hash (bytes): 与证明相关的数据哈希
#         zkp (dict): 模拟的证明对象

#     Returns:
#         bool: True，模拟成功验证
#     """
#     print(
#         f"    [Crypto] Verifying mock ZKP for public key {public_key.to_string().hex()[:10]}..."
#     )
#     # 在实际系统中，这将返回复杂的加密检查结果，但在我们的模拟中，我们假设只要生成了证明，它就是有效的
#     is_valid = (
#         zkp["public_key"] == public_key.to_string().hex()
#         and zkp["data_hash"] == data_hash.hex()
#     )
#     return is_valid

def generate_zkp_of_signature(data_hash, signature, public_key):
    """
    使用 zksk 构造“知道签名者私钥”的零知识证明。
    模拟离散对数知识证明：证明知道私钥 x，使得 pk = g^x
    """
    print("[ZKP] Generating ZKP with zksk...")

    # 1. 设置椭圆曲线群
    group = EcGroup()
    order = group.order()
    g = group.generator()

    # 2. 生成一个具体的、随机的秘密值 (witness)
    x_value = order.random()

    # 3. 使用这个具体的值来计算 h
    h = g.pt_mul(x_value)

    # 4. 创建符号占位符，用于构建证明声明
    x = Secret()

    # 5. 构建证明声明 (Statement)
    # 声明：我知道一个秘密 x，满足 h == g * x
    stmt = DLRep(h, x * g)

    # 6. 生成证明，并告诉证明器 x 的具体值是什么
    proof = stmt.prove({x: x_value})

    return {
        "zkp_proof": proof,
        "g": g.export(),  # 建议使用 export/import
        "h": h.export()
    }

def verify_zkp(public_key, data_hash, zkp_dict):
    """
    验证零知识证明
    """
    print("[ZKP] Verifying ZKP with zksk...")

    # 1. 设置椭圆曲线群
    group = EcGroup()
    
    # 2. 反序列化公开参数 g 和 h
    #    g 是公开的生成元，可以直接获取
    g = group.generator()
    #    使用 EcPt.from_binary() 来恢复 h
    h = EcPt.from_binary(zkp_dict["h"], group)

    # 3. 重新构建与证明时一致的声明结构
    x = Secret()
    #    确保这里的表达式与生成证明时完全一致
    stmt = DLRep(h, x * g)

    # 4. 直接从字典中获取 proof 对象
    proof = zkp_dict["zkp_proof"]

    # 5. 验证证明
    return stmt.verify(proof)
